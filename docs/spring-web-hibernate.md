# Spring Web Hibernate

## SQL Querying with JPA

- for mysql, we need to start the mysql service as administrator and the root user password is set in `mysql-init.txt` file for logging in
- add the `data-jpa` and `mysql-connector-j` dependencies in pom
- the rest of the queries begin in `setup.sql` where we create a new user for our spring boot project, a database, a table etc.
- the datasource url is specified as `jdbc:mysql://{url}/{dbname}`
- having datasource url, username and password allows the connect to the database with specified user and creates beans for DataSource, EntityManager etc
- hibernate is used by default for spring boot jpa

### Hibernate annotated basics

- Specific classes for `StudentHbDao` and `StudentMbDao` are required for it to work with hibernate and mybatis respectively so recheck the imports in the `StudentService`
  - The `Student` class used also differs to recheck those imports in `StudentService` and `StudentController`
- we have clases mapped to tables and their fields mapped to columns
- `@Entity` requires a no-arg constructor so we use `@NoArgsConstructor` using lombok
- If the `@Entity` is not in same package as the current spring boot application class, we need to add the `@EntityScan` annotation and specify the packages where to find the entity classes
- `@Column`/`@Table` is optional and by default it uses the same name as the java variable/class respectively but better to be explicit
- `@GenerateValue` is used to specify that the key will be generated by DB and there are different strategies to it
- Often used along with `AUTO_INCREMENT` which takes the values where the indexing should start in the `CREATE` table command an can be udpated by `ALTER` table command
- Then we create a DAO interface and its implementation with the `@Repository` annotation and autowire the entity manager
  - When we can use the `persist` method of the entity manager to insert object into table as row
  - This also updates the reference of the object inserted to contain the id with which it was inserted if using generatedValue and autoIncrement
- We can also use `@Transactional` from spring-framework package to make the method transactional
  - we should specify these on the service layer as a best practice instead of dao layer
- To update single entity, we can first use entity manager to find them, update the values of the object and then calling `merge` method of the entity manager with new object to update it in DB
  - For multiple entities, refer to JPQL section
- We let the student class implement `Serializable` interface and specify a `serialVersionUID` so as to help with Serialization/Deserialization

### JPQL

- we can use `createQuery("FROM <entityname>")` to make more customized queries and get the results using `getResultList`
  - the entity name uses the name specified in `@Entity` or takes the class name (it is case-sensitive)
  - the field names are the member names in Java and not the column names in SQL so be very careful
- `createQuery` can use `WHERE, AND, OR, LIKE, ORDER BY` etc as well where params are specified as `:<paramname>` like `:pname`
- `createQuery` returns an object of type `TypedQuery`
- Params can be set using `TypedQuery.setParameter(paramName, value)` but should only be set if used
  - if we don't use `:name` then setting `:name` throws exception
- Setting these parameters are safer than directly setting in the string
- If setting parameters for `IN` clause for number column, we should use `List<Integer>` for the parameter type
- For updating multiple entities, we can use `createQuery("UPDATE <entityname> SET)` followed by `executeUpdate()`
- For delete, it works the same way where `entityManager.remove(Student)` is used to remove one record and `createQuery("DELETE FROM <entityname> WHERE)` followed by `executeUpdate()`
- Both update and delete using `executeUpdate` returns the number of records updated/deleted
- We can use `spring.jpa.hibernate.ddl-auto` to create/drop DB tables at app startup/shutdown automatically based on the entities available
  - values available include `create`, `create-only`, `drop`, `create-drop`, `none` etc
- Spring JPA has an interface called `JpaRepository<EntityType, PrimaryKeyType>` which provides ready methods like `findAll, findById, save, deleteById` etc
  - it also makes sure that save is transactional out of the box so we can remove `@Transactional` from the relevant service methods
- This paves the way for `spring-data-rest` which will scan the project for `JpaRepository` entities and automatically create endpoints like `GET, GET (id), POST, PUT, DELETE` with no new code
  - it just needs the dependency `spring-boot-data-rest` to be added to POM
  - the response for these endpoints include the actual data and metadata because its `HATEOAS` compliant

---
